#!/bin/bash
# Объявление функций
# Функцию можно вызвать без аргументов и с аргументами. Функцию можно объявить так:
# function Имя_функции {
# }
# Или так:
# function Имя_функции() {
# }
##
function myfunc() {
echo "Это пример использования функции"
}
count=1
while [ $count -le 3 ]
do
   myfunc
   count=$(($count+1))
done
echo "Это конец цикла"
myfunc
echo "Это конец скрипта"
# Функцию можно вызывать столько раз, сколько нужно. Если вызвать функцию до её объявления, будет ошибка

# Имена для функций должны быть уникальными. Если переопределить ранее объявленную функцию, то новая будет вызываться вместо старой без каких-либо уведомлений или сообщений об ошибках
##
function myfunc() {
echo "Это пример использования функции"
}
myfunc
function myfunc() {
echo "Это переопределенная функция"
}
myfunc

# Использование команды RETURN. Максимальное значение, которое может вернуть RETURN=255.
# !!! В переменной "$?" хранится то, что возвращает функция через RETURN
##
function myfunct2() {
read -p "Введите число: " number
echo "Сложение введенного числа с 10"
return $(($number+10))
}
myfunct2
echo "Результат выполнения функции: " $?

# Пример использования функции
##
function myfunct3() {
read -p "Введите число: " number
echo "Сложение введенного числа с 10"
k=$(($number+10))
}
myfunct3
echo "Результат выполнения функции: $k"

# Запись вывода функции в переменную
##
function myfunc4() {
read -p "Введите число: " number1
echo $(($number1+10)) # ! Обрабатывается результат функции
}
k1=$(myfunc4) # Переменной присваивается значение результата обработки функции
echo "Результат выполнения функции(2): $k1"

# Аргументы функций
##
function addnum() {
if [ ${#} -eq 0 ] || [ ${#} -gt 2 ]
then
   echo -1
elif [ ${#} -eq 1 ]
then
   echo $((${1}+${1}))
else
   echo $((${1}+${2}))
fi
}
echo -n "Сложение 10 и 15: "
value=$(addnum 10 15)
echo $value
echo -n "Сложение одного числа: "
value=$(addnum 10)
echo $value
echo -n "Сложение без чисел: "
value=$(addnum)
echo $value
echo -n "Сложение трех чисел: "
value=$(addnum 10 15 20)
echo $value

# Аргументы функций
# Переделанная программа, аргументы берутся из значений, заданных при запуске скрипта
##
function addnum() {
if [ ${#} -eq 0 ] || [ ${#} -gt 2 ]
then
   echo -1
elif [ ${#} -eq 1 ]
then
   echo $((${1}+${1}))
else
   echo $((${1}+${2}))
fi
}
echo -n "Сложение 1-го и 2-го параметров командной строки: "
value=$(addnum ${1} ${2})
echo $value
echo -n "Сложение одного числа: "
value=$(addnum ${1})
echo $value
echo -n "Сложение без чисел: "
value=$(addnum)
echo $value
echo -n "Сложение трех чисел: "
value=$(addnum ${1} ${2} ${3})
echo $value
# Запустим скрипт: ./myscript.sh 100 200 300

# Работа с ГЛОБАЛЬНЫМИ переменными в функциях
# Глобальные переменные — это переменные, которые видны из любого места bash-скрипта
# Если вы объявили глобальную переменную в основном коде скрипта, к такой переменной можно обратиться из функции
# Почти то же самое справедливо и для глобальных переменных, объявленных в функциях. Обращаться к ним можно и в основном коде скрипта после вызова функций
# По умолчанию все объявленные в скриптах переменные глобальны
##
function myfunc5() {
value=$(($value+10))
}
read -p "Введите значение переменной" value
myfunc5
echo "Новое значение переменной: $value"

# Локальные переменные
# Переменные, которые объявляют и используют внутри функции, могут быть объявлены локальными. Для того, чтобы это сделать, используется ключевое слово "local" перед именем переменной
##
function myfunc6() {
local temp=$((1+5))
echo "Локальная переменная равна $temp"
}
temp=25
myfunc6
echo "Глобальная переменная равна $temp"
# Здесь, когда мы работаем с переменной $temp внутри функции, это не влияет на значение, назначенное переменной с таким же именем за её пределами

# Передача функциям массивов в качестве аргументов
# Попробуем передать функции в качестве аргумента массив. Сразу хочется сказать, что РАБОТАТЬ такая конструкция БУДЕТ НЕПРАВИЛЬНО
##
function arrayfunc() {
echo "Параметры: ${@}"
array=${1}
echo "Переданный массив: ${array[*]}"
}
myarray=(1 2 3 4 5)
echo "Оригинальный массив: ${myarray[*]}"
arrayfunc $myarray

# Как видно из примера, при передаче функции массива, она получит доступ лишь к его первому элементу.
# Для того, чтобы эту проблему решить, из массива надо извлечь имеющиеся в нём данные и передать их функции как самостоятельные аргументы
# Если надо, внутри функции полученные ей аргументы можно снова собрать в массив
##
function arrayfunc() {
echo "Параметры: ${@}"
local newarray=(${@}) # Можно записать и так: local newarray=("${@}")
echo "Новый переданный массив: ${newarray[*]}"
}
myarray=(1 2 3 4 5)
echo "Оригинальный массив: ${myarray[*]}"
arrayfunc ${myarray[*]}

# Рекурсивные функции
##
