#!/bin/bash
# Каждому процессу позволено иметь до девяти открытых ДЕСКРИПТОРОВ файлов
# Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2
# 0, STDIN — стандартный поток ввода, как буд-то вводишь с клавиатуры. Можно заменить символами: "0<" и "0<<"- ввод с замещением и ввод с добавлением
# 1, STDOUT — стандартный поток вывода, вывод на экран. Можно перенаправить в файл: "1> test.txt" и "1>> test.txt"- вывод с замещением и вывод с добавлением
# 2, STDERR — стандартный поток ошибок, вывод на экран. Можно перенаправить в файл "2> error.txt", если просто "2>", то вывод будет на экран

# Перенаправление потока ошибок
##
ls -l xfile 2> myfile # Ошибки о несуществующем файле запишутся в файл "myfile"

# Перенаправление потоков ошибок и вывода
##
ls -l 04_BASH_Ввод_Вывод_file xfile xxfile 2> errorcontent 1> correctcontent # Ошибки пишутся в файл ошибок, коректный вывод - в другой файл

# Перенаправление STDERR, и STDOUT в один и тот же файл
##
ls -l 04_BASH_Ввод_Вывод_file xfile xxfile &> content # ВСЁ В ФАЙЛ. STDERR, и STDOUT можно перенаправить в один и тот же файл, воспользовавшись командой >&

# Временное перенаправление, или перенаправление вывода одной строки в скриптах
##
echo "Это ошибка" >& 2 # !!! ВЕСЬ ВЫВОД СТРОКИ - В ОШИБКИ, А ОШИБКИ ПО-УМОЛЧАНИЮ, НА ЭКРАН
echo "Это нормальный вывод"

# Временное перенаправление, или перенаправление вывода одной строки в скриптах
##
echo "Это ошибка" >& 2 # ВЕСЬ ВЫВОД СТРОКИ - В ОШИБКИ, А ОШИБКИ ПО-УМОЛЧАНИЮ, НА ЭКРАН
echo "Это нормальный вывод"
# При запуске скрипта можно отдельно вывести ошибки в файл: "./myscript 2> myfile"

# Временное перенаправление, или перенаправление вывода одной строки в скриптах
##
echo "Это ошибка" >& 2> error # !!! ВЕСЬ ВЫВОД СТРОКИ - В ОШИБКИ, А ОШИБКИ В ФАЙЛ
echo "Это нормальный вывод"

# Постоянное перенаправление вывода командой EXEC
# Если в скрипте нужно перенаправлять много выводимых на экран данных, добавлять соответствующую команду к каждому вызову echo неудобно
# Вместо этого можно задать перенаправление вывода в определённый дескриптор на время выполнения скрипта, воспользовавшись командой EXEC
##
exec >& 1> file
echo "Это ошибка"
echo "Это ошибка часть 2"
echo "Это нормальный вывод"
echo "Это нормальный вывод часть 2"

# Или так
##
exec 1> file
echo "Это ошибка"
echo "Это ошибка часть 2"
echo "Это нормальный вывод"
echo "Это нормальный вывод часть 2"

# Команду exec можно использовать не только в начале скрипта, но и в других местах:
## 
exec 2> my_error_file
echo "Это ошибка" # Выводит строку в STDOUT на экран
echo "Это ошибка часть 2" # Выводит строку в STDOUT на экран
exec 1> my_file # Все, что идет в STDOUT выводится в файл
echo "Это нормальный вывод" # Выводит строку в файл my_file
echo "Это нормальный вывод часть 2" >& 2 # Выводит строку в дескриптор STDERR, а он, по первой строке программы, пишет в файл

#----------------------------------------------------------------------------------------------------------------------------------------------------
# ! Эту программу нужно запускать отдельно от вышенаписанных программ, т.к. они вносят неисправность в работу этой программы
# Перенаправление ввода в скриптах
# Команда EXEC позволяет сделать источником данных для STDIN какой-нибудь файл
##
#file2=04_BASH_Ввод_Вывод_file
#exec 0< $file2
#count=1
#while read line
#do
#   echo "Строка $count: $line"
#   count=$(($count+1))
#done
#----------------------------------------------------------------------------------------------------------------------------------------------------

# Создание собственного перенаправления вывода
# Назначить дескриптор для вывода данных можно, используя команду EXEC
##
exec 3> output_in_file
echo "Это будет на экране"
echo "А это будет в файле" >& 3
echo "И это будет на экране"

# Создание дескрипторов файлов для ввода данных
##
#----------------------------------------------------------------------------------------------------------------------------------------------------
# ! Эту программу нужно запускать отдельно от вышенаписанных программ, т.к. они вносят неисправность в работу этой программы
#file2=04_BASH_Ввод_Вывод_file
#exec 6<& 0 # "6 и <&" пишутся слитно, иначе будет ошибка
#exec 0< $file2
#count=1
#while read line
#do
#   echo "Строка номер $count: $line"
#   count=$(($count+1))
#done
#exec 0<& 6 # Если первым идет числовой дескриптор, а потом амперсанд, то они пишутся слитно, иначе будет ошибка
#read -p "Вы завершили" answer
#case $answer in
#   y) echo "До свидания";;
#   n) echo "Это конец программы";;
#esac
#----------------------------------------------------------------------------------------------------------------------------------------------------

# Закрытие дескрипторов файлов
# Оболочка автоматически закрывает дескрипторы файлов после завершения работы скрипта
# Однако, в некоторых случаях нужно закрывать дескрипторы вручную, до того, как скрипт закончит работу
# Для того, чтобы закрыть дескриптор, его нужно перенаправить в "&-"
##
exec 3> testfile
echo "Это будет выводиться в файл" >& 3
exec 3>&- # Если первым идет числовой дескриптор, а потом амперсанд, то они пишутся слитно, иначе будет ошибка
echo "Это НЕ будет выводиться в файл" >& 3
# После исполнения скрипта мы получим сообщение об ошибке, потому что мы попытались обратиться к несуществующему дескриптору
# ! Если вы отправляли данные в файл, потом закрыли дескриптор, потом — открыли снова, оболочка заменит существующий файл новым,
# ! т.е. всё то, что было записано в этот файл ранее, будет утеряно

#----------------------------------------------------------------------------------------------------------------------------------------------------
# ! Эту программу нужно запускать отдельно от вышенаписанных программ, т.к. они вносят неисправность в работу этой программы
# Получение сведений об открытых дескрипторах
# Для того, чтобы узнать PID текущего процесса, можно использовать специальную переменную окружения $$, в которую оболочка записывает текущий PID
# и команды "lsof. "Ключ "-a" используется для выполнения операции логического И над результатами, возвращёнными благодаря использованию двух других ключей:
#lsof -a -p $$ -d 0,1,2 # 0,1,2 это номера дескрипторов
#----------------------------------------------------------------------------------------------------------------------------------------------------

#----------------------------------------------------------------------------------------------------------------------------------------------------
# ! Эту программу нужно запускать отдельно от вышенаписанных программ, т.к. они вносят неисправность в работу этой программы
# Получение сведений об открытых дескрипторах в скрипте
##
#exec 3> myfile1
#exec 6> myfile2
#exec 7< myfile3
#lsof -a -p $$ -d 0,1,2,3,6,7
#----------------------------------------------------------------------------------------------------------------------------------------------------

# Заглушить вывод
##
ls -l 04_BASH_Ввод_Вывод_file xfile xxfile >& /dev/null # Заглушить вывод всего
ls -l 04_BASH_Ввод_Вывод_file xfile xxfile 1> /dev/null # Заглушить вывод результата программы
ls -l 04_BASH_Ввод_Вывод_file xfile xxfile 2> /dev/null # Заглушить вывод ошибок

#Если нужно очистить файл, не удаляя его:
##
cat /dev/null > myfile