#!/bin/bash

# Чтение параметров командной строки
# Оболочка bash назначает специальным переменным, называемым позиционными параметрами, введённые при вызове скрипта параметры командной строки
# $0 — имя скрипта, $1-$9 параметры
###
echo $0
echo $1
echo $2
echo $3
# Запустим сценарий с параметрами: 5 10 15 ! Параметры нужно разделять пробелами

#
###
sum=$(($1+$2))
echo "Первый параметр: $1"
echo "Второй параметр: $2"
echo "Сумма параметров: $sum"
# Запустим сценарий с параметрами: 5 10

# Сценариям можно передавать не только числа, но и строки
###
echo "Привет, $1, как у тебя дела?"
# Запустим сценарий с параметром: Adam

# Передача сценарию строки с пробелами
###
echo "Привет, $1, как у тебя дела?" # Если в параметре используются пробелы, параметр должен быть заключен в двойные кавычки
# Запустим сценарий с параметром: "Adam Adamov"

# Передача сценарию больше 9 параметров. !При обращении к параметру с номером больше 9, имя переменной надо заключать в фигурные скобки, например так: ${10}
###
echo "1 параметр: $1"
echo "2 параметр: ${2}" # Но ничего не мешает ВСЕГДА использовать в имени переменной для параметра командной строки фигурные скобки, тогда никогда не ошибешься
echo "3 параметр: $3"
echo "4 параметр: ${4}"
echo "5 параметр: $5"
echo "6 параметр: $6"
echo "7 параметр: $7"
echo "8 параметр: ${8}"
echo "9 параметр: ${9}"
echo "10 параметр: ${10}"
echo "11 параметр: ${11}"
echo "12 параметр: ${12}"
# Запустим сценарий с параметрами: 5 10 15 20 25 30 35 40 45 50 55 60

# Проверка параметров командной строки
# Если скрипт вызван без параметров, но для нормальной работы кода предполагается их наличие, возникнет ошибка
# Поэтому рекомендуется всегда проверять наличие параметров, переданных сценарию при вызове
###
if [ -n "$1" ] # !!! При проверке параметр НУЖНО БРАТЬ В ДВОЙНЫЕ КАВЫЧКИ !!!
then
   echo "Командной строке передан параметр: $1"
else
   echo "Не найдено параметров!"
fi

# Подсчёт параметров
# В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет для этого специальную переменну
# А именно, переменная ($#) содержит количество параметров, переданных сценарию при вызове
###
echo "Скрипту при вызове передано $# параметра (ов)" # Выводит количество параметров, переданных сценарию при вызове
echo "Скрипту при вызове передано ${#} параметра (ов)" # Чтобы не запутаться, можно ВСЕГДА использовать в имени переменной для параметра командной строки фигурные скобки
echo "Скрипту при вызове передано ${!#} параметра (ов)" # Выводит ПОСЛЕДНИЙ переданный командной строке параметр
# Запустим сценарий с параметрами: 5 10 15 20

# Захват всех параметров командной строки
# Переменная $* (${*})  содержит все параметры, введённые в командной строке, в виде единого «слова»
# В переменной $@ (${@}) параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах
###
echo "Используется \$*-метод: $*" # Переменная $* (${*})  содержит все параметры, введённые в командной строке, в виде единого «слова»
echo "Используется \$*-метод: ${*}" # Чтобы не запутаться, можно ВСЕГДА использовать в имени переменной для параметра командной строки фигурные скобки
echo "Используется \$@-метод: $@" # В переменной $@ (${@}) параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах
echo "Используется \$@-метод: ${@}" # Чтобы не запутаться, можно ВСЕГДА использовать в имени переменной для параметра командной строки фигурные скобки
# Запустим сценарий с параметрами: 5 10 елка сапог "плакучая ива" 30 кусачки "пушистый носатый барбос"

# Захват всех параметров командной строки в цикле
###
count=0
for param in "$*"
do
   echo "Метод \$*: параметр $param"
   count=$((count+1))
done
for param in "$@"
do
   echo "Метод \$@: параметр $param"
   count=$((count+1))
done
# Запустим сценарий с параметрами: 1 2 3 4 5

# Команда SHIFT
# Использовать команду SHIFT в bash-скриптах следует с осторожностью, так как она, в прямом смысле слова, сдвигает значения позиционных параметров
# SHIFT, по умолчанию, сдвигает значения позиционных параметров влево. Например, значение переменной $3 становится значением переменной $2, значение $2 переходит в $1,
# а то, что было до этого в $1, безвозвратно теряется. Однако при этом значение переменной $0, содержащей имя скрипта, не меняется.
###
count=1
while [ -n "${1}" ] # !!! При проверке параметр НУЖНО БРАТЬ В ДВОЙНЫЕ КАВЫЧКИ !!!
do
   echo "Параметр командной строки \$1 = ${1}"
   echo "Параметр командной строки \$2 = ${2}"
   echo "Параметр командной строки \$3 = ${3}"
   echo "Параметр командной строки \$4 = ${4}"
count=$((count+1))
shift
done
# Запустим сценарий с параметрами: 1 2 3 4


## ! Эту программу нужно запускать отдельно от вышенаписанных программ, т.к. они вносят неисправность в работу этой программы
## Ключи командной строки. Команды CASE и ESAC
####
#if [ ${#} -eq 0 ]; then # Проверка на случай, если никакие параметры не переданы
#    echo "Скрипт вызван без аргументов. Пожалуйста, передайте аргументы."
#    exit 1
#fi
#echo "$1"
#while [ -n "${1}" ]
#do
#   case "${1}" in # CASE, которая сверяет переданный ей ключ со списком обрабатываемых скриптом ключей
#      -a) echo "Параметр -a найден";; # После проверяемого значения ставится закрывающая круглая скобка
#      -b) echo "Параметр -b найден";; # Каждый блок проверки завершается двойной точкой с запятой (;;)
#      -c) echo "Параметр -c найден";; # Написание параметра должно в точности соответствовать тому, как оно передается (-c)- вместе с "тире"
#      *) echo "Параметр не найден в ${1}";; # (*) используется для обработки всех остальных вариантов по умолчанию
#   esac # Запрывает блок проверок (Обратное написание от CASE)
#   shift # Сдвигает переданные параметры влево
#done
## Запустим скрипт с параметрами: –a –b –c –d

----------------------------------------------------------------------------------------------------------------------------------------------------

## ! Эту программу нужно запускать отдельно от вышенаписанных программ, т.к. они вносят неисправность в работу этой программы
## Как различать ключи и параметры
## Ключи с одним тире (-h), параметры с двумя тире (--color)
####
#while [ -n "${1}" ]
#do
#   case "${1}" in # CASE, которая сверяет переданный ей ключ со списком обрабатываемых скриптом ключей
#      -a) echo "Параметр -a найден";; # После проверяемого значения ставится закрывающая круглая скобка
#      -b) echo "Параметр -b найден";; # Каждый блок проверки завершается двойной точкой с запятой (;;)
#      -c) echo "Параметр -c найден";; # Написание параметра должно в точности соответствовать тому, как оно передается (-c)- вместе с "тире"
#      --) shift
#   break;;
#      *) echo "Параметр не найден в ${1}";; # (*) - все остальное нужно прописывать в самом конце, когда все уже перечислено, иначе будет ошибка
#   esac # Закрывает блок проверок (Обратное написание от CASE)
#   shift # Сдвигает переданные параметры влево
#done
#count=1
#for param in ${@}
#do
#   echo "Параметр $count: $param"
#   count=$((count+1))
#done


# Обработка ключей со значениями
# По мере усложнения скриптов, столкнёмся с ситуациями, когда обычных ключей уже недостаточно, а значит, нужно будет использовать ключи с некими значениями
# Например, вызов сценария в котором используется подобная возможность, выглядит так: "./myscript -a test1 -b -c test2"
# Скрипт должен уметь определять, когда вместе с ключами командной строки используются дополнительные параметры
##

----------------------------------------------------------------------------------------------------------------------------------------------------

## ! Эту программу нужно запускать отдельно от вышенаписанных программ, т.к. они вносят неисправность в работу этой программы
#while [ -n "${1}" ]
#do
#   case "${1}" in # CASE, которая сверяет переданный ей ключ со списком обрабатываемых скриптом ключей
#      -a) echo "Параметр -a найден";; # После проверяемого значения ставится закрывающая круглая скобка
#      -b) param="${2}"
#      echo "Опция -b найдена с параметром $param"
#      shift;;
#      -c) echo "Параметр -c найден";;
#      --) shift
#   break;;
#      *) echo "Параметр не найден в ${1}";;
#   esac
#   shift
#done
#count=1
#for param in ${@}
#do
#   echo "Параметр $count: $param"
#   count=$((count+1))
#done
# Запустим скрипт с параметрами: -a -b test1 -d

----------------------------------------------------------------------------------------------------------------------------------------------------

# Использование стандартных ключей
##
